[[dev-guide-templates-creating]]
= Creating New Templates
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]


== Overview

include::dev_guide/templates/templates_using.adoc[tag=default-templates]

In addition, you can write your own templates on an {product-title}, 
create templates outside of the environment and upload them, edit existing templates
to create new templates, or create templates from existing {product-title} objects. 

After you have created the template, see xref:../../dev_guide/templates/templates_edit.adoc#dev-guide-templates-editing[Modifying Templates]
for ideas on what you can do with templates, including:

* Limiting the resource quotas 

* Limiting the size of containers

* Limiting persistent volume usage

* Limiting the number of pods per node

* Configure resources manually for each node  

Before you start, take a look at the xref:other-recommendations[Template Creation Best Practices]
section at the end of this topic.

[[writing-templates]]
== Writing New Templates
You can define new templates to make it easy to recreate all the objects of your
application.  The template will define the objects it creates along with some
metadata to guide the creation of those objects.

.A Simple Template Object Definition (YAML)
----
apiVersion: v1
kind: Template
metadata:
  name: redis-template
  annotations:
    description: "Description"
    iconClass: "icon-redis"
    tags: "database,nosql"
objects:
- apiVersion: v1
  kind: Pod
  metadata:
    name: redis-master
  spec:
    containers:
    - env:
      - name: REDIS_PASSWORD
        value: ${REDIS_PASSWORD}
      image: dockerfile/redis
      name: master
      ports:
      - containerPort: 6379
        protocol: TCP
parameters:
- description: Password used for Redis authentication
  from: '[A-Z0-9]{8}'
  generate: expression
  name: REDIS_PASSWORD
labels:
  redis: master
----

The template format is golang templates [http://golang.org/pkg/text/template/#pkg-overview].

== Uploading templates

//tag::uploading-templates[]
If you have a JSON or YAML file that defines a template, you can upload
the template to projects using the CLI. This saves the template to the project
for repeated use by any user with appropriate access to that project.
Instructions on xref:writing-templates[writing your own templates] are provided
later in this topic.

To upload a template to your current project's template library, pass the JSON
or YAML file with the following command:

----
$ oc create -f <filename>
----

You can upload a template to a different project using the `-n` option with the
name of the project:

----
$ oc create -f <filename> -n <project>
----

The template is now available for selection using the web console or the CLI.
//end::uploading-templates[]

[[edit-a-template]]
== Creating a Template from Another Template

You can create a new template based on one that has already been uploaded to your project: 

. Make a copy of the template you want to edit:
+
----
cp <template-name> <new-template-name>
----

. Run the following command:
+
----
$ oc edit template <template>
----
+
The template opens in a VI editor.

. Edit the fields as needed and save. 

You can now xref:../../dev_guide/templates_using.adoc#dev-guide-templates-using[use the template to create objects] the same as any other template.

Where the defaults templates live
Best practices for modifying the existing ones (bad idea? backup? cp to a new file and change the app name?)

[[export-as-template]]
== Creating a Template from Existing Objects
ifdef::openshift-online[]
If you are upgrading from {product-title} Starter to {product-title} Pro, use
`oc export all` to export all of your existing objects. {product-title} Pro does
not support per-object resource migration.
endif::[]

Rather than writing an entire template from scratch, you can export existing
objects from your project in template form, and then modify the template from
there by adding parameters and other customizations. To export objects in a
project in template form, run:

----
$ oc export <object-type> <object-name> --as-template=<template_name> > <path-to-template_filename>
----

The `<template-name>` is assigned to the `name` parameter in the template and 
`<path-to-template_filename>` is the name and location where the template is created.

The `<object-type>` can be any of the following:

- BuildConfig
- Build
- DeploymentConfig
- ImageStream
- Pod
- ReplicationController
- Route
- Service
- Template


[[other-recommendations]]
== Template Creation Best Practices

* Group related services together in the management console by adding the
`service.alpha.openshift.io/dependencies` annotation to the Service object in
your template.
+
.Group the Frontend and Database Services Together on the Management Console Overview

[source,yaml]
----
kind: "Template"
apiVersion: "v1"
objects:
  - kind: "Service"
    apiVersion: "v1"
    metadata:
      name: "frontend"
      annotations:
        "service.alpha.openshift.io/dependencies": "[{\"name\": \"database\", \"kind\": \"Service\"}]"
...
  - kind: "Service"
    apiVersion: "v1"
    metadata:
      name: "database"
----

* Set xref:compute_resources.adoc#dev-compute-resources[memory, CPU], and
xref:../architecture/additional_concepts/storage.adoc#pvc-resources[storage]
default sizes to make sure your application is given enough resources to run
smoothly.

* Avoid referencing the `latest` tag from images if that tag is used across major
versions. This may cause running applications to break when new images are
pushed to that tag.

* A good template builds and deploys cleanly without requiring modifications
after the template is deployed.

* Design your template visually, as it helps understand the required components.

* Provide meaningful names to resources and use labels to describe your resources (labels are used as selectors for some resources).

* Templates can be shared or per-project, and common templates are in the *openshift* namespace/project.

* Currently there is no ability to set a Readme on templates, so be as verbose and complete in the template's description.

* Once the resources in a template are processed and deployed, they can be modified with the CLI.

* You should constrain the CPU and memory a container in a pod can use. 

* When the resources in a template are created, if there is a BuildConfiguration defined, it will only start an automated build if there is an ImageChange trigger defined. This will change in the next release and we will be able to launch a build on resource creation.

* Parameterize everything a user of your template might want to customize so they can control the behavior of the template when they instantiate it.


How to update the default
Where the defaults templates live
Best practices for modifying the existing ones (bad idea? backup? cp to a new file and change the app name?)




