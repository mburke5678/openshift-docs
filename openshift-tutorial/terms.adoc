[[openshjift-tutorial-terms]]
= Important Terms
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:

toc::[]
{nbsp} +

Before we get to far in, we need to get some things straight. This topic describes the terminology that we use in this tutorial and that you will use everytime you work with {product-title}.

image::terms.png[terms, 594,254, align="center"]

Namespace::

_Namespaces_ are a Kubernetes concept and we really don't talk much about them in {product-title}.

Kubernetes defines namespaces as link:https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/[_multiple virtual clusters backed by the same physical cluster_]. They state that link:https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/[_namespace provides the scope for pods, services, and deployments in the cluster_]. 

[TIP]
====
Don't worry, we will define those terms later, too
====

image::project-namespace.png[projects, 409,400, float="right"]

Namespaces, essentially, provide a mechanism for different users, teams, customers, and so forth to share a cluster. Namespaces are identified by a user-specified name and an internally-provided UID (unique identifier). 

One thing that namespaces do not do well is preventing users from accessing other namespaces. That is where projects come in.

Projects:: 
A _project_ is an {product-title} implementation of a Kubernetes namespace. You can think of a project as a wrapper for a name space. 

xref:../../architecture/core_concepts/projects_and_users.html#projects[Projects] provide everything that namespaces provide, but with additional tools, including the security that namespaces lack. You can control which users can access which namespaces and communication between projects is not allowed. 

Most users interact with most objects and resources through projects. 

Nodes:
A _node_ is the physical system where pod and their containers reside. 

Nodes contain the services required to run pods and containers, including the container runtime service, the Kubernetes (Kubelet) service, and a simple network proxy. 

In short, {product-title} is comprised of the following nodes:

* *Master*. The master node is where the administrator manages other nodes in a cluster and schedules pods to run on nodes.
* *Infrastructure*. Infrastructure nodes are nodes that are labeled to run pieces of the OpenShift Container Platform environment.
* *Nodes*. The other nodes are where the pods and containers reside. 

xref:../../architecture/infrastructure_components/kubernetes_infrastructure.html#node[Nodes]

OpenShift Container Platform creates nodes from a cloud provider, physical systems, or virtual systems. 

Pod::
A _pod_ is simply a collection of one or more containers on the same host. Pods can be thought of as analagous to a physical system where containers are installed.

Because all of the containers in a pod are on the same phyical system, the containers can share resources such as storage. Each pod has a dedicated IP address that is load balanced through a service (which is defined next). 

//http://demandware.edgesuite.net/abaq_prd/on/demandware.static/-/Sites-siteCatalog_Burpee_US/default/dw8b3edca3/Category%20Content%20Images/CLP%20Vegetables/CATID-2470_Peas.jpg

image::pods.png[projects, 409,400, float="right"]
Service::
A _service_ is an abstraction that defines a set of pods. xref:../../architecture/core_concepts/pods_and_services.html#services[Services] identify a set of replicated pods in order to proxy the connections to the pods, acting as a front-end to the pods. Back-end pods can be added to or removed from a service while the service remains consistently available, enabling anything that depends on the service to refer to it at a consistent address.  

Services are associated with pods through label selectors in the pod that match to labels (key/value pairs) in the pod specification.

Users can access services using either the service IP address/port combination or the service name. 

Containers::
Containers are where the work happens. 

Docker tells you that containers link:https://www.docker.com/what-container[are an abstraction at the app layer that packages code and dependencies together]. But, you can think of a container as a virtual machine -- a virtual machine that usually runs a single process (often called a "micro-service"), such as a web server or a database, though containers can be used for arbitrary workloads.


Containers based on an image.  can communicate; share volumes (persistent storage); Your software wrapped in a complete filesystem containing everything it needs to run

run one process at a time

image::node.png[node, 562,347 align="center"]

Images::
_Imges_ are essentially templates for creating containers.


Replication controller::
A replication controller is


Route::
Makes service accessible; creates a router (ha-proxy or hardware); external DNS name, load-balancing

Builds::
The {product-title} documentation calls says that a xref:../../architecture/core_concepts/builds_and_image_streams.html#builds[_build is the process of transforming input parameters into a resulting object_].

But, you can think of a build as how an application gets deployed.


* Build configuration is a description of how to build source code and base image into new image; S2I images (python, PHP, Ruby,Java) or docker files; builds create an image in the Docker registry
* Deployment config defines the template for a pod and manages new images or changes; dc = microservice; multiple deployment strategies; 



    Container - 
    Image - We are talking about docker images; read-only and used to create containers
    Pod - One or more docker containers that run together
    Service - Provides a common DNS name to access a pod (or replicated set of pods)
    Project - A project is a group of services that are related logically
    Deployment - an update to your application triggered by a image change or config change
    Build - The process of turning your source code into a runnable image
    BuildConfig - configuration data that determines how to manage your build
    Route - a labeled and DNS mapped network path to a service from outside OpenShift
    Master - The foreman of the OpenShift architecture, the master schedules operations, watches for problems, and orchestrates everything
    Node - Where the compute happens, your software is run on nodes



